// Generated by CoffeeScript 1.3.1
var RDFaParser;

(function(exports) {
  var Context, Description, ElementData, ID, RDFA_USES_VOCAB, RDF_IRI, RDF_XML_LITERAL, State, XHV_IRI, addPropToObj, addToPropListToObj, bnodeCounter, builder, contexts, extract, getNextBNode, getOrCreateNode, inherit, init, makeLiteral, walk;
  RDF_IRI = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
  XHV_IRI = "http://www.w3.org/1999/xhtml/vocab#";
  RDF_XML_LITERAL = RDF_IRI + 'XMLLiteral';
  RDFA_USES_VOCAB = "http://www.w3.org/ns/rdfa#usesVocabulary";
  ID = '@id';
  getNextBNode = null;
  extract = function(doc, base, profile) {
    var state;
    if (profile == null) {
      profile = 'html';
    }
    getNextBNode = bnodeCounter();
    state = init(doc, base, profile);
    builder.start(state);
    walk(doc.documentElement, state);
    return builder.complete(state);
  };
  init = function(doc, base, profile) {
    var resolveURI, resolver, state;
    resolver = doc.createElement('a');
    resolveURI = function(ref) {
      resolver.href = ref;
      return resolver.href;
    };
    if (doc.getElementsByTagName('base').length) {
      base = resolveURI('');
    }
    state = new State(base, profile, resolveURI);
    return state;
  };
  walk = function(el, state) {
    var change, child, desc, _i, _len, _ref, _results;
    if (el.attributes.length) {
      desc = new Description(el, state);
      change = builder.visit(desc, state);
      if (change) {
        state = state.createSubState(desc, change.subject, change.incomplete);
      }
    }
    _ref = el.childNodes;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        _results.push(walk(child, state));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };
  builder = {
    start: function(state) {
      state.result = {
        all: {}
      };
      getOrCreateNode(state.result, state.context.base);
      return null;
    },
    visit: function(desc, state) {
      var activeSubject, adder, baseObj, completedNode, completingNode, content, currentNode, hasLinks, incomplete, inlist, links, literal, localNode, nestedNode, oNode, oref, prop, props, rel, resource, result, rev, revLinks, sref, type, types, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1;
      result = state.result;
      if (desc.vocab) {
        baseObj = getOrCreateNode(result, desc.context.base);
        addPropToObj(baseObj, RDFA_USES_VOCAB, {
          '@id': desc.vocab
        });
      }
      activeSubject = desc.subject || desc.parentSubject;
      currentNode = getOrCreateNode(result, activeSubject);
      localNode = getOrCreateNode(result, desc.subject || desc.resource);
      links = desc.linkProperties;
      revLinks = desc.reverseLinkProperties;
      props = desc.contentProperties;
      inlist = desc.inlist;
      incomplete = desc.parentIncomplete;
      hasLinks = links.length || revLinks.length;
      if (!(desc.subject || hasLinks || props.length)) {
        return {
          subject: activeSubject,
          incomplete: incomplete
        };
      }
      if (incomplete) {
        completedNode = getOrCreateNode(result, incomplete.subject);
        if (desc.subject) {
          completingNode = localNode;
        } else {
          completingNode = getOrCreateNode(result, incomplete.incompleteSubject);
          currentNode = completingNode;
        }
        if (completingNode) {
          adder = incomplete.inlist ? addToPropListToObj : addPropToObj;
          _ref = incomplete.linkProperties;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            rel = _ref[_i];
            adder(completedNode, rel, {
              '@id': completingNode[ID]
            });
          }
          _ref1 = incomplete.reverseLinkProperties;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            rev = _ref1[_j];
            adder(completingNode, rev, {
              '@id': completedNode[ID]
            });
          }
          incomplete = null;
        }
      }
      if (hasLinks && !desc.resource) {
        incomplete = {
          linkProperties: links,
          reverseLinkProperties: revLinks,
          inlist: inlist,
          subject: currentNode[ID],
          incompleteSubject: getNextBNode()
        };
      }
      types = desc.types;
      if (types) {
        for (_k = 0, _len2 = types.length; _k < _len2; _k++) {
          type = types[_k];
          addPropToObj(localNode, "@type", type);
        }
      }
      adder = inlist ? addToPropListToObj : addPropToObj;
      resource = desc.resource;
      oNode = null;
      nestedNode = currentNode;
      if (resource) {
        oNode = getOrCreateNode(result, resource);
        if (desc.scoped) {
          nestedNode = oNode;
        }
        oref = {
          "@id": resource
        };
        if (revLinks.length) {
          sref = {
            "@id": activeSubject
          };
          for (_l = 0, _len3 = revLinks.length; _l < _len3; _l++) {
            rev = revLinks[_l];
            adder(oNode, rev, sref);
          }
        }
      }
      if (resource || inlist) {
        for (_m = 0, _len4 = links.length; _m < _len4; _m++) {
          rel = links[_m];
          adder(currentNode, rel, oref);
        }
      }
      content = desc.content;
      if ((content != null) || inlist) {
        if (content != null) {
          literal = makeLiteral(content, desc.datatype, desc.lang);
        }
        for (_n = 0, _len5 = props.length; _n < _len5; _n++) {
          prop = props[_n];
          adder(currentNode, prop, literal);
        }
      }
      return {
        subject: nestedNode[ID],
        incomplete: incomplete
      };
    },
    complete: function(state) {
      var add, items, key, obj, s, _ref;
      items = [];
      _ref = state.result.all;
      for (s in _ref) {
        obj = _ref[s];
        add = false;
        for (key in obj) {
          if (key !== "@id") {
            add = true;
            break;
          }
        }
        if (add) {
          items.push(obj);
        }
      }
      return items;
    }
  };
  getOrCreateNode = function(result, id) {
    var obj;
    obj = result.all[id];
    if (!obj) {
      obj = result.all[id] = {
        "@id": id
      };
    }
    return obj;
  };
  addPropToObj = function(obj, prop, value) {
    var values;
    values = obj[prop];
    if (!values) {
      values = obj[prop] = [];
    } else if (!values.push) {
      values = obj[prop] = [values];
    }
    return values.push(value);
  };
  addToPropListToObj = function(obj, prop, value) {
    var l, values;
    values = obj[prop];
    if (values instanceof Array) {
      if (values[0]['@list']) {
        values = values[0]['@list'];
      } else {
        l = [];
        values.unshift({
          '@list': l
        });
        values = l;
      }
    } else if (values) {
      values = values['@list'];
    } else {
      values = [];
      obj[prop] = {
        "@list": values
      };
    }
    if (value != null) {
      return values.push(value);
    }
  };
  makeLiteral = function(value, datatype, lang) {
    if (datatype) {
      return {
        "@value": value,
        "@type": datatype
      };
    } else if (lang) {
      return {
        "@value": value,
        "@language": lang
      };
    } else {
      return value;
    }
  };
  State = (function() {

    State.name = 'State';

    function State(base, profile, resolveURI) {
      this.context = new Context(resolveURI, profile, base, null, contexts[profile]);
      this.lang = null;
      this.incomplete = null;
      this.subject = base;
    }

    State.prototype.createSubState = function(desc, subject, incomplete) {
      var subState;
      subState = inherit(this);
      subState.context = desc.context;
      subState.lang = desc.lang;
      subState.subject = subject;
      subState.incomplete = incomplete;
      return subState;
    };

    return State;

  })();
  Context = (function() {

    Context.name = 'Context';

    function Context(resolveURI, profile, base, vocab, prefixes) {
      this.resolveURI = resolveURI;
      this.profile = profile;
      this.base = base;
      this.vocab = vocab != null ? vocab : null;
      this.prefixes = prefixes != null ? prefixes : {};
    }

    Context.prototype.createSubContext = function(base, vocab, prefixes) {
      var iri, pfx, subPrefixes;
      if (base == null) {
        base = this.base;
      }
      if (vocab == null) {
        vocab = this.vocab;
      }
      subPrefixes = inherit(this.prefixes);
      for (pfx in prefixes) {
        iri = prefixes[pfx];
        subPrefixes[pfx] = iri;
      }
      return new Context(this.resolveURI, this.profile, base, vocab, subPrefixes);
    };

    Context.prototype.expandTermOrCurieOrIRI = function(expr) {
      var iri;
      if (expr.indexOf(":") !== -1) {
        return this.expandCurieOrIRI(expr);
      }
      if (this.vocab) {
        return this.vocab + expr;
      }
      iri = this.prefixes[expr] || this.prefixes[expr.toLowerCase()];
      if (iri) {
        return iri;
      }
      return null;
    };

    Context.prototype.expandCurieOrIRI = function(expr) {
      var i, ns, pfx, safeCurie, term;
      safeCurie = false;
      if (expr.match(/^\[(.+)]$/)) {
        expr = RegExp.$1;
        safeCurie = true;
      }
      i = expr.indexOf(':');
      if (i === -1) {
        return expr;
      }
      pfx = expr.substring(0, i);
      term = expr.substring(i + 1);
      if (pfx === '_') {
        return expr;
      }
      if (term.slice(0, 2) === "//") {
        return expr;
      }
      if (pfx.length === 0) {
        return XHV_IRI + term;
      }
      ns = this.prefixes[pfx];
      if (ns) {
        return ns + term;
      }
      return expr;
    };

    Context.prototype.expandAndResolve = function(curieOrIri) {
      var iri, resolved;
      if (curieOrIri === '[]') {
        return null;
      }
      iri = this.expandCurieOrIRI(curieOrIri);
      if (iri[0] === '_') {
        return iri;
      }
      resolved = this.resolveURI(iri);
      if (resolved.length === iri.length) {
        return iri;
      }
      return resolved;
    };

    return Context;

  })();
  Description = (function() {

    Description.name = 'Description';

    function Description(el, state) {
      var about, data, hasContentAttrs, lit, props, propsAsLinks, rels, resource, resourceIsTyped, revs, _ref;
      this.parentSubject = state.subject;
      this.parentIncomplete = state.incomplete;
      data = new ElementData(el, state.context, this.parentSubject);
      this.errors = data.errors;
      this.lang = (_ref = data.getLang()) != null ? _ref : state.lang;
      this.vocab = data.getVocab();
      this.context = data.context;
      this.types = data.getTypes();
      props = data.getProperties();
      resource = data.getResource();
      rels = data.getRels();
      revs = data.getRevs();
      about = data.getAbout();
      resourceIsTyped = !!(this.types && !about);
      hasContentAttrs = !!((data.contentAttr != null) || (data.datatypeAttr != null));
      propsAsLinks = !!(props && (!(rels || revs)) && (resource || resourceIsTyped) && !hasContentAttrs);
      this.contentProperties = props && !propsAsLinks ? props : [];
      this.linkProperties = rels ? rels : propsAsLinks ? props : [];
      this.reverseLinkProperties = revs || [];
      this.inlist = data.isInlist();
      if (resource) {
        this.resource = resource;
      } else if (resourceIsTyped && (rels || props)) {
        this.resource = getNextBNode();
      }
      this.scoped = this.resource && (!(propsAsLinks || hasContentAttrs)) || resourceIsTyped;
      this.subject = about || this.getResourceAsSubject();
      if (this.contentProperties) {
        lit = data.getLiteral();
        if (lit) {
          this.content = lit.value;
          this.datatype = lit.datatype;
        }
      }
    }

    Description.prototype.getResourceAsSubject = function() {
      var links;
      links = this.linkProperties.length || this.reverseLinkProperties.length;
      if (this.resource && !links) {
        return this.resource;
      } else if (this.types && !(this.contentProperties.length || links)) {
        return getNextBNode();
      }
    };

    return Description;

  })();
  ElementData = (function() {

    ElementData.name = 'ElementData';

    function ElementData(el, parentContext, parentSubject) {
      this.el = el;
      this.attrs = this.el.attributes;
      this.isRoot = this.el.parentNode === this.el.ownerDocument;
      this.tagName = this.el.nodeName.toLowerCase();
      this.parentSubject = parentSubject;
      this.errors = [];
      this.context = parentContext.createSubContext(this.getBase(), this.getVocab(), this.getPrefixes());
      this.contentAttr = this.getContentAttr();
      this.datatypeAttr = this.getDatatypeAttr();
    }

    ElementData.prototype.getBase = function() {
      return null;
    };

    ElementData.prototype.getLang = function() {
      var _ref, _ref1;
      return ((_ref = this.attrs['xml:lang']) != null ? _ref.value : void 0) || ((_ref1 = this.attrs.lang) != null ? _ref1.value : void 0);
    };

    ElementData.prototype.getContentAttr = function() {
      if (this.context.profile === 'html') {
        if (this.tagName === 'time' && (this.attrs.datetime != null)) {
          return this.attrs.datetime.value;
        } else if (this.tagName === 'data' && (this.attrs.value != null)) {
          return this.attrs.value.value;
        }
      }
      if (this.attrs.content != null) {
        return this.attrs.content.value;
      }
    };

    ElementData.prototype.getDatatypeAttr = function() {
      var dt;
      if (this.attrs.datatype != null) {
        dt = this.attrs.datatype.value;
        if (!dt) {
          return "";
        }
        return this.context.expandTermOrCurieOrIRI(dt);
      }
    };

    ElementData.prototype.getVocab = function() {
      var _ref;
      return (_ref = this.attrs.vocab) != null ? _ref.value : void 0;
    };

    ElementData.prototype.getPrefixes = function() {
      var i, ns, pfx, pfxs, prefixes, val, _i, _ref, _ref1;
      prefixes = this.getNamespaces();
      val = (_ref = this.attrs.prefix) != null ? _ref.value : void 0;
      if (!val) {
        return prefixes;
      }
      pfxs = val.replace(/^\s+|\s+$/g, "").split(/:?\s+/);
      for (i = _i = 0, _ref1 = pfxs.length; _i < _ref1; i = _i += 2) {
        pfx = pfxs[i];
        ns = pfxs[i + 1];
        prefixes[pfx] = ns;
      }
      return prefixes;
    };

    ElementData.prototype.getNamespaces = function() {
      var attr, prefixes, _i, _len, _ref;
      prefixes = {};
      _ref = this.attrs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attr = _ref[_i];
        if (attr.name.match(/^xmlns:/)) {
          prefixes[attr.name.substring(6)] = attr.value;
        }
      }
      return prefixes;
    };

    ElementData.prototype.getAbout = function() {
      if (this.attrs.about != null) {
        return this.context.expandAndResolve(this.attrs.about.value);
      } else if (this.isRoot) {
        return this.parentSubject;
      } else if ((this.tagName === 'head' || this.tagName === 'body') && !(this.attrs.resource != null)) {
        return this.parentSubject;
      }
    };

    ElementData.prototype.getResource = function() {
      if (this.attrs.resource != null) {
        return this.context.expandAndResolve(this.attrs.resource.value);
      } else if (this.attrs.href != null) {
        return this.context.resolveURI(this.attrs.href.value);
      } else if (this.attrs.src != null) {
        return this.context.resolveURI(this.attrs.src.value);
      }
    };

    ElementData.prototype.getTypes = function() {
      var v, values, _ref;
      values = (_ref = this.attrs["typeof"]) != null ? _ref.value.split(/\s+/) : void 0;
      if (values) {
        values = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = values.length; _i < _len; _i++) {
            v = values[_i];
            if (v !== 'typeof') {
              _results.push(v);
            }
          }
          return _results;
        })();
      }
      return this.expandAll(values);
    };

    ElementData.prototype.getProperties = function() {
      var _ref;
      return this.expandAll((_ref = this.attrs.property) != null ? _ref.value.split(/\s+/) : void 0);
    };

    ElementData.prototype.getRels = function() {
      var _ref;
      return this.expandAll((_ref = this.attrs.rel) != null ? _ref.value.split(/\s+/) : void 0, true);
    };

    ElementData.prototype.getRevs = function() {
      var _ref;
      return this.expandAll((_ref = this.attrs.rev) != null ? _ref.value.split(/\s+/) : void 0, true);
    };

    ElementData.prototype.expandAll = function(expressions, weak) {
      var expr, iri, isHtml, muted, prop, result, _i, _len;
      if (weak == null) {
        weak = false;
      }
      if (!expressions) {
        return null;
      }
      result = [];
      isHtml = this.context.profile === 'html';
      prop = this.attrs.property != null;
      muted = false;
      for (_i = 0, _len = expressions.length; _i < _len; _i++) {
        expr = expressions[_i];
        if (weak && isHtml && prop && expr.indexOf(':') === -1) {
          muted = true;
          continue;
        }
        iri = this.context.expandTermOrCurieOrIRI(expr);
        if (iri && iri[0] !== '_') {
          result.push(iri);
        }
      }
      if (muted && result.length === 0) {
        return null;
      }
      return result;
    };

    ElementData.prototype.getLiteral = function() {
      var content, datatype, lang, xml;
      datatype = this.getDatatype();
      lang = this.getLang();
      if (datatype === RDF_XML_LITERAL) {
        xml = this.getXML();
      } else {
        content = this.getContent();
      }
      if (content != null) {
        if (datatype) {
          return {
            value: content,
            datatype: datatype
          };
        } else if (lang) {
          return {
            value: content,
            lang: lang
          };
        } else {
          return {
            value: content
          };
        }
      } else {
        return {
          value: xml,
          datatype: datatype
        };
      }
    };

    ElementData.prototype.getContent = function() {
      return this.contentAttr || this.el.textContent;
    };

    ElementData.prototype.getXML = function() {
      return this.el.innerHTML;
    };

    ElementData.prototype.getDatatype = function() {
      var value;
      if (this.datatypeAttr) {
        return this.datatypeAttr;
      } else if (this.context.profile === 'html' && this.tagName === 'time') {
        value = this.getContent();
        if (value.indexOf(' ') !== -1) {
          return null;
        }
        if (value[0] === 'P') {
          return this.context.expandTermOrCurieOrIRI('xsd:duration');
        }
        if (value.indexOf('T') > -1) {
          return this.context.expandTermOrCurieOrIRI('xsd:dateTime');
        } else if (value.indexOf(':') > -1) {
          return this.context.expandTermOrCurieOrIRI('xsd:time');
        } else if (value.match(/^\d{4,}$/)) {
          return this.context.expandTermOrCurieOrIRI('xsd:gYear');
        } else if (value.match(/^\d{4,}-\d{2}$/)) {
          return this.context.expandTermOrCurieOrIRI('xsd:gYearMonth');
        } else if (value.match(/^\d{4,}-\d{2}-\d{2}(Z|[+-]\d{2}:?\d{2})?$/)) {
          return this.context.expandTermOrCurieOrIRI('xsd:date');
        }
      }
      return null;
    };

    ElementData.prototype.isInlist = function() {
      return this.attrs.inlist !== void 0;
    };

    return ElementData;

  })();
  contexts = {
    html: {
      "grddl": "http://www.w3.org/2003/g/data-view#",
      "ma": "http://www.w3.org/ns/ma-ont#",
      "owl": "http://www.w3.org/2002/07/owl#",
      "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
      "rdfa": "http://www.w3.org/ns/rdfa#",
      "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
      "rif": "http://www.w3.org/2007/rif#",
      "skos": "http://www.w3.org/2004/02/skos/core#",
      "skosxl": "http://www.w3.org/2008/05/skos-xl#",
      "wdr": "http://www.w3.org/2007/05/powder#",
      "void": "http://rdfs.org/ns/void#",
      "wdrs": "http://www.w3.org/2007/05/powder-s#",
      "xhv": "http://www.w3.org/1999/xhtml/vocab#",
      "xml": "http://www.w3.org/XML/1998/namespace",
      "xsd": "http://www.w3.org/2001/XMLSchema#",
      "cc": "http://creativecommons.org/ns#",
      "ctag": "http://commontag.org/ns#",
      "dc": "http://purl.org/dc/terms/",
      "dcterms": "http://purl.org/dc/terms/",
      "foaf": "http://xmlns.com/foaf/0.1/",
      "gr": "http://purl.org/goodrelations/v1#",
      "ical": "http://www.w3.org/2002/12/cal/icaltzd#",
      "og": "http://ogp.me/ns#",
      "rev": "http://purl.org/stuff/rev#",
      "sioc": "http://rdfs.org/sioc/ns#",
      "v": "http://rdf.data-vocabulary.org/#",
      "vcard": "http://www.w3.org/2006/vcard/ns#",
      "schema": "http://schema.org/",
      "describedby": "http://www.w3.org/2007/05/powder-s#describedby",
      "license": "http://www.w3.org/1999/xhtml/vocab#license",
      "role": "http://www.w3.org/1999/xhtml/vocab#role"
    }
  };
  bnodeCounter = function() {
    var count, prefix;
    prefix = "_:gen-" + ((new Date().getTime()).toString(16)) + "-";
    count = 0;
    return function() {
      return prefix + count++;
    };
  };
  inherit = function(obj) {
    var ctor;
    ctor = function() {};
    ctor.prototype = obj;
    return new ctor;
  };
  exports.extract = extract;
  exports.Description = Description;
  exports.State = State;
  exports.Context = Context;
  exports.ElementData = ElementData;
  return exports.contexts = contexts;
})(typeof exports !== "undefined" && exports !== null ? exports : RDFaParser = {});
