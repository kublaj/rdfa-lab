// Generated by CoffeeScript 1.3.1
var RDFaJSON;

(function(exports) {
  var ID, RDFA_USES_VOCAB, RDFaParser, addPropToObj, addToPropListToObj, builder, getOrCreateNode, makeLiteral;
  if (typeof require === 'function') {
    RDFaParser = require("./parser");
  } else {
    RDFaParser = window.RDFaParser;
  }
  RDFA_USES_VOCAB = "http://www.w3.org/ns/rdfa#usesVocabulary";
  ID = '@id';
  exports.extract = function(doc, base, profile) {
    if (profile == null) {
      profile = 'html';
    }
    if (doc == null) {
      doc = window.document;
    }
    if (!(base && !(typeof window !== "undefined" && window !== null))) {
      base = window.location.href;
    }
    return RDFaParser.parse(builder, doc, base, profile);
  };
  builder = {
    start: function(state) {
      state.result = {
        all: {}
      };
      getOrCreateNode(state.result, state.context.base);
      return null;
    },
    visit: function(desc, state) {
      var activeSubject, adder, baseObj, completedNode, completingNode, content, currentNode, hasLinks, incomplete, inlist, links, literal, localNode, nestedNode, oNode, oref, prop, props, rel, resource, result, rev, revLinks, sref, type, types, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1;
      result = state.result;
      if (desc.vocab) {
        baseObj = getOrCreateNode(result, desc.context.base);
        addPropToObj(state, baseObj, RDFA_USES_VOCAB, {
          '@id': desc.vocab
        });
      }
      activeSubject = desc.subject || desc.parentSubject;
      currentNode = getOrCreateNode(result, activeSubject);
      localNode = getOrCreateNode(result, desc.subject || desc.resource);
      links = desc.linkProperties;
      revLinks = desc.reverseLinkProperties;
      props = desc.contentProperties;
      inlist = desc.inlist;
      incomplete = desc.parentIncomplete;
      hasLinks = !!(links || revLinks);
      if (state.keepList) {
        state.keepList = incomplete !== null || activeSubject === desc.parentSubject;
      }
      if (!(desc.subject || hasLinks || props)) {
        return {
          subject: activeSubject,
          incomplete: incomplete
        };
      }
      if (incomplete) {
        completedNode = getOrCreateNode(result, incomplete.subject);
        if (desc.subject) {
          completingNode = localNode;
        } else {
          completingNode = getOrCreateNode(result, incomplete.incompleteSubject);
          currentNode = completingNode;
        }
        adder = incomplete.inlist ? addToPropListToObj : addPropToObj;
        if (incomplete.linkProperties) {
          _ref = incomplete.linkProperties;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            rel = _ref[_i];
            adder(state, completedNode, rel, {
              '@id': completingNode[ID]
            });
          }
        }
        if (incomplete.reverseLinkProperties) {
          _ref1 = incomplete.reverseLinkProperties;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            rev = _ref1[_j];
            adder(state, completingNode, rev, {
              '@id': completedNode[ID]
            });
          }
        }
        incomplete = null;
      }
      if (hasLinks && !desc.resource) {
        incomplete = {
          linkProperties: links,
          reverseLinkProperties: revLinks,
          inlist: inlist,
          subject: currentNode[ID],
          incompleteSubject: state.getNextBNode()
        };
      }
      types = desc.types;
      if (types) {
        for (_k = 0, _len2 = types.length; _k < _len2; _k++) {
          type = types[_k];
          addPropToObj(state, localNode, "@type", type);
        }
      }
      adder = inlist ? addToPropListToObj : addPropToObj;
      resource = desc.resource;
      oNode = null;
      nestedNode = currentNode;
      if (resource) {
        oNode = getOrCreateNode(result, resource);
        if (desc.scoped) {
          nestedNode = oNode;
        }
        oref = {
          "@id": resource
        };
        if (revLinks) {
          sref = {
            "@id": activeSubject
          };
          for (_l = 0, _len3 = revLinks.length; _l < _len3; _l++) {
            rev = revLinks[_l];
            adder(state, oNode, rev, sref);
          }
        }
      }
      if (resource || inlist) {
        if (links) {
          for (_m = 0, _len4 = links.length; _m < _len4; _m++) {
            rel = links[_m];
            adder(state, currentNode, rel, oref);
          }
        }
      }
      content = desc.content;
      if ((content != null) || inlist) {
        if (content != null) {
          literal = makeLiteral(content, desc.datatype, desc.lang);
        }
        if (props) {
          for (_n = 0, _len5 = props.length; _n < _len5; _n++) {
            prop = props[_n];
            adder(state, currentNode, prop, literal);
          }
        }
      }
      return {
        subject: nestedNode[ID],
        incomplete: incomplete
      };
    },
    complete: function(state) {
      var add, items, key, obj, s, _ref;
      items = [];
      _ref = state.result.all;
      for (s in _ref) {
        obj = _ref[s];
        add = false;
        for (key in obj) {
          if (key !== "@id") {
            add = true;
            break;
          }
        }
        if (add) {
          items.push(obj);
        }
      }
      return items;
    }
  };
  getOrCreateNode = function(result, id) {
    var obj;
    obj = result.all[id];
    if (!obj) {
      obj = result.all[id] = {
        "@id": id
      };
    }
    return obj;
  };
  addPropToObj = function(state, obj, prop, value) {
    var values;
    values = obj[prop];
    if (!values) {
      values = obj[prop] = [];
    } else if (!values.push) {
      values = obj[prop] = [values];
    }
    return values.push(value);
  };
  addToPropListToObj = function(state, obj, prop, value) {
    var l, newList, values;
    values = obj[prop];
    if (values instanceof Array) {
      if (values[0]['@list'] && state.keepList) {
        values = values[0]['@list'];
      } else {
        l = [];
        values.unshift({
          '@list': l
        });
        values = l;
      }
    } else if (values) {
      if (state.keepList) {
        values = values['@list'];
      } else {
        newList = [];
        obj[prop] = [
          values, {
            "@list": newList
          }
        ];
        values = newList;
      }
    } else {
      values = [];
      obj[prop] = {
        "@list": values
      };
    }
    if (value != null) {
      values.push(value);
    }
    return state.keepList = true;
  };
  return makeLiteral = function(value, datatype, lang) {
    if (datatype) {
      return {
        "@value": value,
        "@type": datatype
      };
    } else if (lang) {
      return {
        "@value": value,
        "@language": lang
      };
    } else {
      return value;
    }
  };
})(typeof exports !== "undefined" && exports !== null ? exports : RDFaJSON = {});
