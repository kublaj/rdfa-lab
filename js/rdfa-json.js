// Generated by CoffeeScript 1.3.1
var RDFaJSON;

(function(ns) {
  var Context, bnode, itemOrRef, nextBNode, parseElement, storedKey;
  ns.extract = function(doc, base) {
    var idMap, root, top;
    doc || (doc = window.document);
    base || (base = typeof window !== "undefined" && window !== null ? window.location.href : void 0);
    top = {};
    if (base) {
      top["@id"] = base;
    }
    root = {
      '@context': {},
      '@graph': [top]
    };
    idMap = {};
    parseElement(doc.documentElement, root, top, null, {}, idMap);
    return {
      data: root,
      map: idMap
    };
  };
  parseElement = function(el, root, current, vocab, hanging, idMap) {
    var attrs, child, ctxt, graph, i, inlist, item, items, key, l, next, pfx, pfxs, predicate, rev, sub, top, type, types, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref, _ref1, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    attrs = el.attributes;
    graph = root['@graph'];
    ctxt = new Context(root['@context'], current);
    if (attrs != null) {
      if ((_ref = attrs.vocab) != null ? _ref.value : void 0) {
        vocab = attrs.vocab.value;
        ctxt.update('rdfa', "http://www.w3.org/ns/rdfa#");
        top = graph[0];
        top['rdfa:usesVocabulary'] = vocab;
      }
      if ((_ref1 = attrs.prefix) != null ? _ref1.value : void 0) {
        pfxs = attrs.prefix.value.split(/:?\s+/);
        for (i = _i = 0, _ref2 = pfxs.length; _i <= _ref2; i = _i += 2) {
          pfx = pfxs[i];
          ns = pfxs[i + 1];
          if ((_ref3 = attrs.lang) != null ? _ref3.value : void 0) {
            ctxt.update(pfx, ns);
          }
        }
        ctxt.update('@language', attrs.lang.value);
      }
      if (attrs.resource != null) {
        next = {
          '@id': attrs.resource.value
        };
      } else if (attrs.href != null) {
        next = {
          '@id': attrs.href.value
        };
      } else if (attrs.src != null) {
        next = {
          '@id': attrs.src.value
        };
      } else if (attrs.about != null) {
        next = {
          '@id': attrs.about.value
        };
      }
      if (!next && attrs["typeof"]) {
        next = {};
      }
      predicate = ((_ref4 = attrs.property) != null ? _ref4.value : void 0) || ((_ref5 = attrs.rel) != null ? _ref5.value : void 0) || hanging.rel;
      if (predicate) {
        if (next) {
          value = next;
        } else if (attrs.property && (attrs.content != null)) {
          value = attrs.content.value;
        } else if (!(attrs.rel || attrs.rev || hanging.rel || hanging.rev)) {
          if (((_ref6 = attrs.datatype) != null ? _ref6.value : void 0) === 'rdf:XMLLiteral') {
            value = el.innerHTML;
          } else {
            value = el.textContent;
          }
        }
        if (attrs.datatype) {
          value = {
            '@value': value
          };
          if (attrs.datatype.value) {
            value['@type'] = attrs.datatype.value;
          }
        }
      }
      if (attrs["typeof"]) {
        types = attrs["typeof"].value.split(/\s+/);
        for (_j = 0, _len = types.length; _j < _len; _j++) {
          type = types[_j];
          if (vocab && type.indexOf(':') === -1) {
            ctxt.update(type, vocab + type);
          }
        }
        (next || current)['@type'] = types;
      }
      inlist = (attrs.inlist !== void 0) || (hanging.rel && hanging.inlist);
      if (value) {
        if (predicate) {
          _ref7 = predicate.split(/\s+/);
          for (i = _k = 0, _len1 = _ref7.length; _k < _len1; i = ++_k) {
            key = _ref7[i];
            key = storedKey(key, ctxt, vocab);
            if (key) {
              if (current[key]) {
                items = current[key];
                if (inlist) {
                  if (items instanceof Array) {
                    if (items[0]['@list']) {
                      items = items[0]['@list'];
                    } else {
                      l = [];
                      items.unshift({
                        '@list': l
                      });
                      items = l;
                    }
                  } else {
                    items = items['@list'];
                  }
                }
              } else {
                items = [];
                current[key] = inlist ? {
                  '@list': items
                } : items;
              }
              item = itemOrRef(value, i, idMap);
              items.push(item);
            }
          }
        }
        rev = ((_ref8 = attrs.rev) != null ? _ref8.value : void 0) || hanging.rev;
        if (rev) {
          _ref9 = rev.split(/\s+/);
          for (i = _l = 0, _len2 = _ref9.length; _l < _len2; i = ++_l) {
            key = _ref9[i];
            key = storedKey(key, ctxt, vocab);
            item = itemOrRef(current, true, idMap);
            items = value[key] || (value[key] = []);
            items.push(item);
            if (!predicate) {
              graph.push(value);
            }
          }
        }
        hanging = {};
      } else if (attrs.rel || attrs.rev) {
        hanging = {
          rel: (_ref10 = attrs.rel) != null ? _ref10.value : void 0,
          rev: (_ref11 = attrs.rev) != null ? _ref11.value : void 0,
          inlist: attrs.inlist !== void 0
        };
      } else if (next) {
        if (((function() {
          var _len3, _m, _ref12, _results;
          _ref12 = el.childNodes;
          _results = [];
          for (_m = 0, _len3 = _ref12.length; _m < _len3; _m++) {
            sub = _ref12[_m];
            if (sub.nodeType === 1) {
              _results.push(sub);
            }
          }
          return _results;
        })()).length) {
          graph.push(next);
        }
      }
    }
    _ref12 = el.childNodes;
    for (_m = 0, _len3 = _ref12.length; _m < _len3; _m++) {
      child = _ref12[_m];
      if (child.nodeType === 1) {
        parseElement(child, root, next || current, vocab, hanging, idMap);
      }
    }
  };
  Context = (function() {

    Context.name = 'Context';

    function Context(rootCtxt, current) {
      this.rootCtxt = rootCtxt;
      this.current = current;
      this.localCtxt = {};
    }

    Context.prototype.update = function(key, ref) {
      var ctxt;
      ctxt = this.rootCtxt;
      if (this.rootCtxt[key] && this.rootCtxt[key] !== ref) {
        ctxt = this.localCtxt;
        this.current['@context'] = this.localCtxt;
      }
      return ctxt[key] = ref;
    };

    return Context;

  })();
  storedKey = function(key, ctxt, vocab) {
    var iri, splitPos;
    splitPos = key != null ? key.indexOf(':') : void 0;
    if (splitPos > -1) {

    } else {
      if (vocab) {
        iri = vocab + key;
        ctxt.update(key, iri);
      } else {
        return null;
      }
    }
    return key;
  };
  itemOrRef = function(value, asRef, idMap) {
    var id;
    if (asRef && typeof value === 'object' && !value['@value']) {
      id = value['@id'] || (value['@id'] = nextBNode());
      return {
        '@id': id
      };
    } else {
      return value;
    }
  };
  bnode = 0;
  return nextBNode = function() {
    return '_:GEN' + bnode++;
  };
})(typeof exports !== "undefined" && exports !== null ? exports : RDFaJSON = {});
