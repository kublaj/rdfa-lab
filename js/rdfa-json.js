// Generated by CoffeeScript 1.3.1
var RDFaJSON;

(function(ns) {
  var Context, Extraction;
  ns.extract = function(doc, base) {
    var extract;
    doc || (doc = window.document);
    base || (base = typeof window !== "undefined" && window !== null ? window.location.href : void 0);
    extract = new Extraction(base);
    extract.start(doc.documentElement);
    return extract;
  };
  Extraction = (function() {

    Extraction.name = 'Extraction';

    function Extraction(base, profile) {
      this.base = base;
      this.profile = profile != null ? profile : 'html';
      this.top = {};
      if (this.base) {
        this.top["@id"] = this.base;
      }
      this.data = {
        '@context': {},
        '@graph': [this.top]
      };
      this.idMap = {};
      this.bnode_counter = 0;
    }

    Extraction.prototype.start = function(el) {
      return this.parseElement(el, this.top, null, {});
    };

    Extraction.prototype.parseElement = function(el, current, vocab, hanging) {
      var child, next, _i, _len, _ref, _ref1;
      if (el.attributes != null) {
        _ref = this.nextState(el, current, vocab, hanging), next = _ref[0], vocab = _ref[1], hanging = _ref[2];
      }
      _ref1 = el.childNodes;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        child = _ref1[_i];
        if (child.nodeType === 1) {
          this.parseElement(child, next || current, vocab, hanging);
        }
      }
    };

    Extraction.prototype.nextState = function(el, current, vocab, hanging) {
      var attrs, ctxt, graph, i, inlist, item, items, key, l, next, pfx, pfxs, predicate, rev, sub, tagName, type, types, value, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref10, _ref11, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      attrs = el.attributes;
      graph = this.data['@graph'];
      ctxt = new Context(this.data['@context'], current);
      tagName = el.nodeName.toLowerCase();
      if ((_ref = attrs.vocab) != null ? _ref.value : void 0) {
        vocab = attrs.vocab.value;
        ctxt.update('rdfa', "http://www.w3.org/ns/rdfa#");
        this.top['rdfa:usesVocabulary'] = vocab;
      }
      if ((_ref1 = attrs.prefix) != null ? _ref1.value : void 0) {
        pfxs = attrs.prefix.value.split(/:?\s+/);
        for (i = _i = 0, _ref2 = pfxs.length; _i <= _ref2; i = _i += 2) {
          pfx = pfxs[i];
          ns = pfxs[i + 1];
          ctxt.update(pfx, ns);
        }
        if ((_ref3 = attrs.lang) != null ? _ref3.value : void 0) {
          ctxt.update('@language', attrs.lang.value);
        }
      }
      if (attrs.resource != null) {
        next = {
          '@id': attrs.resource.value
        };
      } else if (attrs.href != null) {
        next = {
          '@id': attrs.href.value
        };
      } else if (attrs.src != null) {
        next = {
          '@id': attrs.src.value
        };
      } else if (attrs.about != null) {
        next = {
          '@id': attrs.about.value
        };
      }
      if (!next && attrs["typeof"]) {
        next = {};
        if (this.profile === 'html') {
          if (tagName === 'head' || tagName === 'body') {
            next['@id'] = this.top['@id'];
          }
        }
      }
      predicate = ((_ref4 = attrs.property) != null ? _ref4.value : void 0) || ((_ref5 = attrs.rel) != null ? _ref5.value : void 0) || hanging.rel;
      if (predicate) {
        if (next) {
          value = next;
        } else if (attrs.property && (attrs.content != null)) {
          value = attrs.content.value;
        } else if (!(attrs.rel || attrs.rev || hanging.rel || hanging.rev)) {
          if (((_ref6 = attrs.datatype) != null ? _ref6.value : void 0) === 'rdf:XMLLiteral') {
            value = el.innerHTML;
          } else {
            value = el.textContent;
          }
        }
        if (attrs.datatype) {
          value = {
            '@value': value
          };
          if (attrs.datatype.value) {
            value['@type'] = attrs.datatype.value;
          }
        }
      }
      if (attrs["typeof"]) {
        types = attrs["typeof"].value.split(/\s+/);
        for (_j = 0, _len = types.length; _j < _len; _j++) {
          type = types[_j];
          if (vocab && type.indexOf(':') === -1) {
            ctxt.update(type, vocab + type);
          }
        }
        (next || current)['@type'] = types;
      }
      inlist = (attrs.inlist !== void 0) || (hanging.rel && hanging.inlist);
      if (value) {
        if (predicate) {
          _ref7 = predicate.split(/\s+/);
          for (i = _k = 0, _len1 = _ref7.length; _k < _len1; i = ++_k) {
            key = _ref7[i];
            key = ctxt.storedKey(key, vocab);
            if (key) {
              if (current[key]) {
                items = current[key];
                if (inlist) {
                  if (items instanceof Array) {
                    if (items[0]['@list']) {
                      items = items[0]['@list'];
                    } else {
                      l = [];
                      items.unshift({
                        '@list': l
                      });
                      items = l;
                    }
                  } else {
                    items = items['@list'];
                  }
                }
              } else {
                items = [];
                current[key] = inlist ? {
                  '@list': items
                } : items;
              }
              item = this.itemOrRef(value, i);
              items.push(item);
            }
          }
        }
        rev = ((_ref8 = attrs.rev) != null ? _ref8.value : void 0) || hanging.rev;
        if (rev) {
          _ref9 = rev.split(/\s+/);
          for (i = _l = 0, _len2 = _ref9.length; _l < _len2; i = ++_l) {
            key = _ref9[i];
            key = ctxt.storedKey(key, vocab);
            item = this.itemOrRef(current, true);
            items = value[key] || (value[key] = []);
            items.push(item);
            if (!predicate) {
              graph.push(value);
            }
          }
        }
        hanging = {};
      } else if (attrs.rel || attrs.rev) {
        hanging = {
          rel: (_ref10 = attrs.rel) != null ? _ref10.value : void 0,
          rev: (_ref11 = attrs.rev) != null ? _ref11.value : void 0,
          inlist: attrs.inlist !== void 0
        };
      } else if (next) {
        if (((function() {
          var _len3, _m, _ref12, _results;
          _ref12 = el.childNodes;
          _results = [];
          for (_m = 0, _len3 = _ref12.length; _m < _len3; _m++) {
            sub = _ref12[_m];
            if (sub.nodeType === 1) {
              _results.push(sub);
            }
          }
          return _results;
        })()).length) {
          graph.push(next);
        }
      }
      return [next, vocab, hanging];
    };

    Extraction.prototype.itemOrRef = function(value, asRef) {
      var id;
      if (asRef && typeof value === 'object' && !value['@value']) {
        id = value['@id'] || (value['@id'] = nextBNode());
        return {
          '@id': id
        };
      } else {
        return value;
      }
    };

    Extraction.prototype.nextBNode = function() {
      return '_:GEN' + this.bnode_counter++;
    };

    return Extraction;

  })();
  return Context = (function() {

    Context.name = 'Context';

    function Context(rootCtxt, current) {
      this.rootCtxt = rootCtxt;
      this.current = current;
      this.localCtxt = {};
    }

    Context.prototype.update = function(key, ref) {
      var ctxt;
      ctxt = this.rootCtxt;
      if (this.rootCtxt[key] && this.rootCtxt[key] !== ref) {
        ctxt = this.current['@context'] = this.localCtxt;
      }
      return ctxt[key] = ref;
    };

    Context.prototype.storedKey = function(key, vocab) {
      var iri, splitPos;
      splitPos = key != null ? key.indexOf(':') : void 0;
      if (splitPos > -1) {

      } else {
        if (vocab) {
          iri = vocab + key;
          this.update(key, iri);
        } else {
          return null;
        }
      }
      return key;
    };

    return Context;

  })();
})(typeof exports !== "undefined" && exports !== null ? exports : RDFaJSON = {});
